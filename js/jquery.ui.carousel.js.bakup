/*
 * jQuery UI Carousel Plugin v2.1
 *
 * Copyright (c) 2011 Richard Scarrott
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Requires:
 * jQuery v1.4+,
 * jQuery UI Widget Factory 1.8+
 *
 */
 
(function($, undefined) {

	// ie alias (excuse: ie is choppy when scrollPos is animated)
	var headache = $.browser.msie && $.browser.version.substr(0, 1) < 9;
	headache = true;

	$.widget('ui.carousel', {
	
		version: 2.1,
		
		options: {
			itemsPerPage: 1,
			itemsPerTransition: 1,
			noOfRows: 1,
			pagination: true,
			nextPrevActions: true,
			speed: 'normal',
			easing: 'swing',
			animate: true,
			startAt: null,
			beforeAnimate: null,
			afterAnimate: null
		},
		
		_create: function() {
		
			this.itemIndex = 0;
			this._elements();
			this.noOfItems = this._elements.items.length / this.options.noOfRows;
			this.itemWidth = this._elements.items.outerWidth(true);
			this.itemsPerPage = this.options.itemsPerPage;
			this._setRunnerWidth();
			this._addMask();
		
			if (typeof this.options.itemsPerPage !== 'number') {
				this._setItemsPerPage();
			}
			
			if (this.noOfItems <= this.itemsPerPage) { return; }
			
			this.noOfPages = Math.ceil((this.noOfItems - this.itemsPerPage) / this.options.itemsPerTransition) + 1;
			
			if (this.options.pagination) {
				this._addPagination();
			}
			
			if (this.options.nextPrevActions) {
				this._addNextPrevActions();
			}
			
			if (this.options.startAt !== null) {
				this.goTo(this.options.startAt);
			}
			
			this._updateUi();
			
		},
		
		_elements: function() {
		
			this._elements = {};
		
			this._elements.container  = this.element;
			this._elements.runner = this._elements.container.find('ul');
			this._elements.items = this._elements.runner.children('li');
			this._elements.mask = null;
			this._elements.pagination = null;
			this._elements.nextAction = null;
			this._elements.prevAction = null;
		
		},
		
		_setRunnerWidth: function() {
		
			var width = this.itemWidth * this.noOfItems;
			this._elements.runner.width(width);
			
		},
		
		_addMask: function() {
		
			var maskHeight = this._elements.runner.outerHeight(true);
			
			this._elements.mask = this._elements.runner
				.wrap('<div class="mask" />')
				.parent()
				.height(maskHeight);
				
			this.maskWidth = this._elements.mask.width();
			
		},
		
		_addPagination: function() {
		
			var self = this,
				links = [],
				i;
			
			for (i = 0; i < this.noOfPages; i++) {
				links[i] = '<li><a href="#item-' + i + '">' + (i + 1) + '</a></li>';
			}
			
			this._elements.pagination = $('<ol class="pagination-links" />')
				.appendTo(this._elements.container)
				.append(links.join(''))
				.delegate('a', 'click.carousel', function() {
					self.goTo($(this).parent().index()  * self.options.itemsPerTransition);
					return false;
				});
				
		},
		
		_addNextPrevActions: function() {
		
			var self = this,
				elems = this._elements;
			
			// bit crap but add() then appendTo() doesn't work in jQuery 1.4.2 so appended individually
			elems.prevAction = $('<a href="#" class="prev">Prev</a>').appendTo(elems.container);
			elems.nextAction = $('<a href="#" class="next">Next</a>').appendTo(elems.container);
				
			elems.nextAction.bind('click.carousel', function() {
				self.next();
				return false;
			});
			
			elems.prevAction.bind('click.carousel', function() {
				self.prev();
				return false;
			});
			
		},
		
		next: function() {
		
			this.itemIndex = this.itemIndex + this.options.itemsPerTransition;
			this._go();
			
		},
		
		prev: function() {
		
			this.itemIndex = this.itemIndex - this.options.itemsPerTransition;
			this._go();
			
		},
		
		_updateUi: function() {
		
			var elems = this._elements,
				index = this.itemIndex;
		
			if (this.options.pagination) {
			
				console.log(Math.ceil(index / this.options.itemsPerTransition));
			
				elems.pagination
					.children('li')
						.removeClass('current')
						.eq(Math.ceil(index / this.options.itemsPerTransition))
							.addClass('current');
			}

			if (this.options.nextPrevActions) {
				elems.nextAction
					.add(elems.prevAction)
						.removeClass('disabled');
						
				if (index === (this.noOfItems - this.itemsPerPage)) {
					elems.nextAction.addClass('disabled');
				}
				else if (index === 0) {
					elems.prevAction.addClass('disabled');
				}
			}
			
		},
		
		goTo: function(index) {
		
			if (typeof index === 'number') {
				this.itemIndex = index;
			}
			else {
				// assume jquery or DOM element
				this.itemIndex = $(index).index();
			}
			
			this._go();
			
		},
		
		_setItemsPerPage: function() {
		
			this.maskWidth = this._elements.mask.width();
			this.itemsPerPage = Math.floor(this.maskWidth / this.itemWidth);
		
		},
		
		_go: function() {
		
			var self = this,
				elems = this._elements,
				nextItem, 
				pos;
			
			if (typeof this.options.itemsPerPage !== 'number') {
				this._setItemsPerPage();
			}
			
			// check whether there are enough items to animate to
			var lastItem = this.noOfItems - this.itemsPerPage
			if (lastItem > lastItem) {
				this.itemIndex = lastItem; // go to last panel - items per transition
			}
			
			if (this.itemIndex < 0) {
				this.itemIndex = 0; // go to first
			}
			
			nextItem = elems.items.eq(this.itemIndex);
			pos = nextItem.position();
			
			this._trigger('beforeAnimate', null, {
				index: this.itemIndex
			});
			
			if (headache) {
			
				// last pos (could be calculated once on init unless number of items is dynamic...)
				var lastPos = elems.items.last().position().left + this.itemWidth - this.maskWidth;
			
				//  check pos doesn't go past last
				if (Math.abs(pos.left) >= lastPos) {
					pos.left = lastPos;
				}
			
				elems.runner
					.stop()
					.animate({left: -pos.left}, this.options.speed, this.options.easing, function() {
						
						self._trigger('afterAnimate', null, {
							index: self.itemIndex
						});
						
					});
			}
			else {
			
				elems.mask
					.stop()
					.animate({'scrollLeft': pos.left}, this.options.speed, this.options.easing, function() {
						
						self._trigger('afterAnimate', null, {
							index: self.itemIndex
						});
						
					});
			
			}
			
			this._updateUi();
			
		},
		
		destroy: function() {
		
			var elems = this._elements;
		
			elems.runner
				.unwrap('.mask')
				.css('left', 'auto');
				
			elems.pagination.remove();
			elems.nextAction.remove();
			elems.prevAction.remove();
			
			// overkill?
			$.each(elems, function() {
				$(this).unbind('.carousel');
			});
		
			$.Widget.prototype.destroy.apply(this, arguments);
			
		}
		
	});
})(jQuery);